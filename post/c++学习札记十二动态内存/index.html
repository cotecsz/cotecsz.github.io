<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="olOwOlo" /><meta name="description" content="C&#43;&#43;学习札记（十二）动态内存 [TOC]
 在之前编写的程序中，对象有严格定义的生存周期：
 全局对象在程序启动时分配，在程序结束时销毁 局部自动对象，在定义所在的程序块时被创建，在离开块时被销毁 局部静态对象，在第一次使用前被创建，在程序结束时被销毁  也仅仅使用过静态内存和栈内存：
 静态内存：局部 static 对象，类static 数据成员，定义在函数外的变量 栈内存：定义在函数内的非 static 对象   除静态内存和栈内存，每个程序还拥有一个内存池存储动态分配的对象，称为自由空间 / 堆 。
1 动态内存与智能指针  C&#43;&#43; 中动态内存通过一对运算符来完成：new 在动态内存中分配空间并返回指向该对象的指针，delete 接受一个动态对象指针，销毁该对象，释放与之关联的内存。 两种智能指针：  shared_ptr ：允许多个指针指向同一个对象 unique_ptr ：&amp;ldquo;独占&amp;quot;所指向的对象   标准库还定义了 weak_ptr 伴随类，是一种弱引用，指向 shared_ptr 所指向的对象  1.1 shared_ptr 类  智能指针也是模版，与vector 一样定义  1 2  shared_ptr&amp;lt;string&amp;gt; p1; shared_ptr&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; p2;   与普通指针一样，解引用返回其指向的对象  1 2  if (p1 &amp;amp; p1-&amp;gt;empty()) *p1 = &amp;#34;hi&amp;#34;;   shared_ptr 和 unique_ptr 都支持的操作：定义，判断，解引用，获取成员，获取对象，交换" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.61.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%E5%8D%81%E4%BA%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="" />
<meta property="og:description" content="C&#43;&#43;学习札记（十二）动态内存 [TOC]
 在之前编写的程序中，对象有严格定义的生存周期：
 全局对象在程序启动时分配，在程序结束时销毁 局部自动对象，在定义所在的程序块时被创建，在离开块时被销毁 局部静态对象，在第一次使用前被创建，在程序结束时被销毁  也仅仅使用过静态内存和栈内存：
 静态内存：局部 static 对象，类static 数据成员，定义在函数外的变量 栈内存：定义在函数内的非 static 对象   除静态内存和栈内存，每个程序还拥有一个内存池存储动态分配的对象，称为自由空间 / 堆 。
1 动态内存与智能指针  C&#43;&#43; 中动态内存通过一对运算符来完成：new 在动态内存中分配空间并返回指向该对象的指针，delete 接受一个动态对象指针，销毁该对象，释放与之关联的内存。 两种智能指针：  shared_ptr ：允许多个指针指向同一个对象 unique_ptr ：&ldquo;独占&quot;所指向的对象   标准库还定义了 weak_ptr 伴随类，是一种弱引用，指向 shared_ptr 所指向的对象  1.1 shared_ptr 类  智能指针也是模版，与vector 一样定义  1 2  shared_ptr&lt;string&gt; p1; shared_ptr&lt;list&lt;int&gt;&gt; p2;   与普通指针一样，解引用返回其指向的对象  1 2  if (p1 &amp; p1-&gt;empty()) *p1 = &#34;hi&#34;;   shared_ptr 和 unique_ptr 都支持的操作：定义，判断，解引用，获取成员，获取对象，交换" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%E5%8D%81%E4%BA%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="C&#43;&#43;学习札记（十二）动态内存 [TOC]
 在之前编写的程序中，对象有严格定义的生存周期：
 全局对象在程序启动时分配，在程序结束时销毁 局部自动对象，在定义所在的程序块时被创建，在离开块时被销毁 局部静态对象，在第一次使用前被创建，在程序结束时被销毁  也仅仅使用过静态内存和栈内存：
 静态内存：局部 static 对象，类static 数据成员，定义在函数外的变量 栈内存：定义在函数内的非 static 对象   除静态内存和栈内存，每个程序还拥有一个内存池存储动态分配的对象，称为自由空间 / 堆 。
1 动态内存与智能指针  C&#43;&#43; 中动态内存通过一对运算符来完成：new 在动态内存中分配空间并返回指向该对象的指针，delete 接受一个动态对象指针，销毁该对象，释放与之关联的内存。 两种智能指针：  shared_ptr ：允许多个指针指向同一个对象 unique_ptr ：&ldquo;独占&quot;所指向的对象   标准库还定义了 weak_ptr 伴随类，是一种弱引用，指向 shared_ptr 所指向的对象  1.1 shared_ptr 类  智能指针也是模版，与vector 一样定义  1 2  shared_ptr&lt;string&gt; p1; shared_ptr&lt;list&lt;int&gt;&gt; p2;   与普通指针一样，解引用返回其指向的对象  1 2  if (p1 &amp; p1-&gt;empty()) *p1 = &#34;hi&#34;;   shared_ptr 和 unique_ptr 都支持的操作：定义，判断，解引用，获取成员，获取对象，交换">

<meta itemprop="wordCount" content="1690">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="C&#43;&#43;学习札记（十二）动态内存 [TOC]
 在之前编写的程序中，对象有严格定义的生存周期：
 全局对象在程序启动时分配，在程序结束时销毁 局部自动对象，在定义所在的程序块时被创建，在离开块时被销毁 局部静态对象，在第一次使用前被创建，在程序结束时被销毁  也仅仅使用过静态内存和栈内存：
 静态内存：局部 static 对象，类static 数据成员，定义在函数外的变量 栈内存：定义在函数内的非 static 对象   除静态内存和栈内存，每个程序还拥有一个内存池存储动态分配的对象，称为自由空间 / 堆 。
1 动态内存与智能指针  C&#43;&#43; 中动态内存通过一对运算符来完成：new 在动态内存中分配空间并返回指向该对象的指针，delete 接受一个动态对象指针，销毁该对象，释放与之关联的内存。 两种智能指针：  shared_ptr ：允许多个指针指向同一个对象 unique_ptr ：&ldquo;独占&quot;所指向的对象   标准库还定义了 weak_ptr 伴随类，是一种弱引用，指向 shared_ptr 所指向的对象  1.1 shared_ptr 类  智能指针也是模版，与vector 一样定义  1 2  shared_ptr&lt;string&gt; p1; shared_ptr&lt;list&lt;int&gt;&gt; p2;   与普通指针一样，解引用返回其指向的对象  1 2  if (p1 &amp; p1-&gt;empty()) *p1 = &#34;hi&#34;;   shared_ptr 和 unique_ptr 都支持的操作：定义，判断，解引用，获取成员，获取对象，交换"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-">1 动态内存与智能指针</a>
      <ul>
        <li><a href="#11-shared-ptr-">1.1 shared_ptr 类</a></li>
        <li><a href="#12-">1.2 直接管理内存</a></li>
        <li><a href="#13-shared-ptr--new-">1.3 shared_ptr 与 new 结合使用</a></li>
        <li><a href="#14-">1.4 智能指针和异常</a></li>
        <li><a href="#15-unique-ptr">1.5 unique_ptr</a></li>
        <li><a href="#16-weak-ptr">1.6 weak_ptr</a></li>
      </ul>
    </li>
    <li><a href="#2-">2 动态数组</a>
      <ul>
        <li><a href="#21-new-">2.1 new 和数组</a></li>
        <li><a href="#22-allocator-">2.2 allocator 类</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="c">C++学习札记（十二）动态内存</h1>
<p>[TOC]</p>
<p>  在之前编写的程序中，对象有严格定义的生存周期：</p>
<ul>
<li>全局对象在程序启动时分配，在程序结束时销毁</li>
<li>局部自动对象，在定义所在的程序块时被创建，在离开块时被销毁</li>
<li>局部静态对象，在第一次使用前被创建，在程序结束时被销毁</li>
</ul>
<p>也仅仅使用过静态内存和栈内存：</p>
<ul>
<li>静态内存：局部 <code>static</code> 对象，类<code>static</code> 数据成员，定义在函数外的变量</li>
<li>栈内存：定义在函数内的非 <code>static</code> 对象</li>
</ul>
<p>  除静态内存和栈内存，每个程序还拥有一个内存池存储动态分配的对象，称为<code>自由空间</code> / <strong><code>堆</code></strong> 。</p>
<h2 id="1-">1 动态内存与智能指针</h2>
<ul>
<li><code>C++</code> 中动态内存通过一对运算符来完成：<code>new</code> 在动态内存中分配空间并返回指向该对象的指针，<code>delete</code> 接受一个动态对象指针，销毁该对象，释放与之关联的内存。</li>
<li>两种智能指针：
<ul>
<li><code>shared_ptr</code> ：允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code> ：&ldquo;独占&quot;所指向的对象</li>
</ul>
</li>
<li>标准库还定义了 <code>weak_ptr</code> 伴随类，是一种弱引用，指向 <code>shared_ptr</code> 所指向的对象</li>
</ul>
<h3 id="11-shared-ptr-">1.1 <code>shared_ptr</code> 类</h3>
<ol>
<li>智能指针也是模版，与<code>vector</code> 一样定义</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>与普通指针一样，解引用返回其指向的对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="o">-</span><span class="o">&gt;</span><span class="n">empty</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
  	<span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">hi</span><span class="s">&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>shared_ptr</code> 和 <code>unique_ptr</code> 都支持的操作：定义，判断，解引用，获取成员，获取对象，交换</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_ptr&lt;T&gt; sp<!-- raw HTML omitted -->unique_ptr&lt;T&gt; up</td>
<td>空智能指针，可以指向类型为 <code>T</code> 的对象</td>
</tr>
<tr>
<td>p</td>
<td>将 <code>p</code> 用作条件判断，若 <code>p</code> 指向一个对象，则为 <code>true</code></td>
</tr>
<tr>
<td>*p</td>
<td>解引用 <code>p</code> ，获得它所指向的对象</td>
</tr>
<tr>
<td>p-&gt;mem</td>
<td>等价于 <code>*p.mem</code></td>
</tr>
<tr>
<td>p.get()</td>
<td>返回 <code>p</code> 中保存的指针</td>
</tr>
<tr>
<td>swap(p, q)<!-- raw HTML omitted -->p.swap(q)</td>
<td>交换 <code>p</code> 和 <code>q</code> 中的指针</td>
</tr>
</tbody>
</table>
<p><code>shared_ptr</code> 独有的操作：初始化，拷贝</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>make_shared&lt;T&gt;*(args)*</td>
<td>返回一个 <code>shared_ptr</code> 指针，指向动态分配类型为 <code>T</code>  使用 <code>args</code> 初始化的对象</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt;p(q)</td>
<td><code>p</code> 是 <code>shared_ptr q</code> 的拷贝，此操作会递增<code>q</code> 中计数器， <code>q</code> 中指针能转换为 <code>T*</code></td>
</tr>
<tr>
<td>p = q</td>
<td><code>p</code> 和 <code>q</code> 都为 <code>shared_ptr</code> ，此操作会递减 <code>p</code> 的引用指数，递增 <code>q</code> 引用指数，<code>p</code> 递减为0，则释放内存</td>
</tr>
<tr>
<td>p.unique()</td>
<td>若 <code>p.use_count()</code> 为 1，返回 <code>true</code> ，否则返回 <code>false</code></td>
</tr>
<tr>
<td>p.use_count()</td>
<td>返回 <code>p</code> 共享对象的智能指针数量，可能很慢，用于调试</td>
</tr>
</tbody>
</table>
<h4 id="111-make-shared-">1.1.1 <code>make_shared</code> 函数</h4>
<ol>
<li>定义方式与模版类相同</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 指向 值为42的 int
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">h</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 指向 值为 &#39;hhhhhhhhh&#39; 的string
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>			<span class="c1">// 指向值初始化为0的 int
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>使用 <code>auto</code> 较为简单</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 指向动态分配的 vector&lt;string&gt;
</span></code></pre></td></tr></table>
</div>
</div><h4 id="112-shared-ptr-">1.1.2 <code>shared_ptr</code> 拷贝与赋值</h4>
<p>   当进行拷贝和赋值时，<code>shared_ptr</code> 都会记录有多少其他的 <code>shared_ptr</code> 指向相同的对象，该关联的计数器称为 <strong><code>引用计数</code></strong> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>当计数器变为 0 时，会自动释放自己所管理的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>			<span class="c1">// 1. 令它指向另一个地址
</span><span class="c1"></span>						<span class="c1">// 2. 递增 q 所指向的对象的引用计数
</span><span class="c1"></span>						<span class="c1">// 3. 递减 r 原来指向的对象的引用计数
</span><span class="c1"></span>						<span class="c1">// 4. r 原来指向的对象已没有饮用者，会自动释放
</span></code></pre></td></tr></table>
</div>
</div><h4 id="113-shared-ptr-">1.1.3 <code>shared_ptr</code> 会自动释放相关联的内存</h4>
<ol>
<li>返回 一个 <code>shared_ptr</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">factory</span><span class="p">(</span><span class="n">T</span> <span class="n">args</span><span class="p">)</span><span class="p">{</span>
  	<span class="c1">// 处理 args
</span><span class="c1"></span>  	
  	<span class="k">return</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>当 <code>p</code> 销毁时，会检测是否为 0</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">factory</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// 使用 p
</span><span class="c1"></span><span class="p">}</span>	<span class="c1">// p 离开作用域，所指向的内存将会被释放
</span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>返回 <code>p</code> 的拷贝</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">args</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">factory</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// 使用 p
</span><span class="c1"></span>  	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>		<span class="c1">// 返回 p 的拷贝，引用计数 + 1
</span><span class="c1"></span><span class="p">}</span>	<span class="c1">// p 离开作用域，但所指向的内存不会被释放
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果将 <code>shared_ptr</code> 存放在一个容器中，当不再需要全部元素时，记得使用 <code>erase</code> 删除不再需要的元素。</p>
</blockquote>
<h4 id="114-">1.1.4 使用了动态生存期的资源的类</h4>
<p>程序使用动态内存的三个原因：</p>
<ol>
<li>程序不知道使用多少对象，如 <code>容器类</code></li>
<li>程序不知道使用对象的准确类型</li>
<li>程序需要在多个多个对象间共享数据</li>
</ol>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p>
</blockquote>
<h4 id="115-strblob-">1.1.5 <code>StrBlob</code> 类</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">StrBlob</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  	<span class="k">typedef</span> <span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
  	<span class="n">StrBlob</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">StrBlob</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">size_type</span> <span class="nf">size</span><span class="p">(</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="p">}</span>
  	<span class="kt">bool</span> <span class="nf">empty</span><span class="p">(</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">empyt</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="p">}</span>
  	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="p">;</span><span class="p">}</span>
  	<span class="kt">void</span> <span class="nf">pop_back</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  	<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
  	<span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>构造函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">StrBlob</span><span class="p">(</span><span class="p">)</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">{</span><span class="p">}</span>
<span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">StrBlob</span><span class="p">(</span><span class="n">initlizer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="o">:</span>
								<span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">il</span><span class="p">)</span><span class="p">)</span><span class="p">{</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>元素访问成员函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
  	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
      	<span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span><span class="o">&amp;</span> <span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">front</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">front on empty StrBlob</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
  	<span class="k">return</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">front</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span><span class="o">&amp;</span> <span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">back</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">back on empty StrBlob</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
  	<span class="k">return</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">back</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StrBlob</span><span class="o">:</span><span class="o">:</span><span class="n">pop_back</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">pop_back on empty StrBlob</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
  	<span class="k">return</span> <span class="n">data</span><span class="o">-</span><span class="o">&gt;</span><span class="n">pop_back</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="12-">1.2 直接管理内存</h3>
<h4 id="121--new-">1.2.1 使用 <code>new</code> 动态分配和初始化对象</h4>
<p>  默认情况下，动态分配的对象是默认初始化的：</p>
<ul>
<li>内置类型/组合类型的对象值是未定义的</li>
<li>类类型对象将用默认构造函数进行初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>		<span class="c1">// pi 指向动态分配的，未初始化的无名对象
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span>	<span class="c1">// 初始化为 空string
</span></code></pre></td></tr></table>
</div>
</div><p>初始化方法：</p>
<ul>
<li>默认为默认初始化</li>
<li>值初始化</li>
<li>列表初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// 默认初始化
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// 2. 值初始化
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">h</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="c1">// 3. 列表初始化
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span><span class="p">;</span>

<span class="c1">// 4. auto: 当且仅当括号中有一个初始化器
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>对动态分配的对象进行初始化通常是个好主意。</p>
</blockquote>
<h4 id="122--const">1.2.2 动态分配 <code>const</code>对象</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="n">string</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="123-">1.2.3 内存耗尽</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="124-">1.2.4 释放动态内存</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">delete</span> <span class="n">p</span><span class="p">;</span>		<span class="c1">//	p必须指向一个动态分配的对象/空指针
</span><span class="c1"></span>						<span class="c1">//  delete的两个动作：1. 销毁给定指针指向的对象  2. 释放对应的内存
</span></code></pre></td></tr></table>
</div>
</div><h4 id="125--delete">1.2.5 指针值和 <code>delete</code></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pi1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span><span class="p">,</span> <span class="o">*</span><span class="n">pd2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">i</span><span class="p">;</span>			<span class="c1">// 错误，i 不是指针
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pi1</span><span class="p">;</span>		<span class="c1">// 未定义：pil 指向一个局部变量
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pd</span><span class="p">;</span>		<span class="c1">// 正确
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pd2</span><span class="p">;</span>		<span class="c1">// 未定义，pd2 指向的内存已经被释放
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pi2</span><span class="p">;</span>		<span class="c1">// 正确
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pci</span><span class="p">;</span>		<span class="c1">// 正确，释放一个 const 对象
</span></code></pre></td></tr></table>
</div>
</div><h4 id="126-">1.2.6 动态对象的生存期直到被释放为止</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">Foo</span><span class="o">*</span> <span class="nf">factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span><span class="p">{</span>
  	<span class="c1">// 处理 args
</span><span class="c1"></span>  	<span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">Foo</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">factory</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="c1">// 局部变量离开作用域，则被销毁，但动态内存无法释放
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>使用 <code>new</code> 和 <code>delete</code> 管理内存的三个常见问题：</p>
<ol>
<li>忘记 <code>delete</code> 动态分配的内存导致的内存泄漏</li>
<li>使用已释放掉的内存</li>
<li>同一块内存释放两次</li>
</ol>
<p>使用智能指针可以避免以上这些问题，对于同一块内存，没有在任何智能指针指向的情况下，智能指针才会自动释放。</p>
</blockquote>
<h4 id="127-delete-">1.2.7 <code>delete</code> 之后要重置指针</h4>
<p><strong>空悬指针</strong> ：在 <code>delete</code> 之后，指针为空悬指针，即指向一块曾经保存数据但现在已经无效的内存的指针。</p>
<p>解决方案：</p>
<ol>
<li>在指针即将离开作用域之前，释放掉它所关联的内存</li>
<li>如果需要保留指针，则在释放内存后，将指针赋予 <code>nullptr</code></li>
</ol>
<h3 id="13-shared-ptr--new-">1.3 <code>shared_ptr</code> 与 <code>new</code> 结合使用</h3>
<ul>
<li>可以使用直接初始化方式初始化一个智能指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 错误，必须使用直接初始化方式
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 正确
</span></code></pre></td></tr></table>
</div>
</div><p>定义和改变 <code>shared_ptr</code> 的其他方法</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_ptr&lt;T&gt; p(q)</td>
<td><code>p</code> 管理内置指针 <code>q</code> 所指向的对象；<code>q</code> 必须为 <code>new</code> 分配的内存且可转换为<code>T*</code></td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(u)</td>
<td><code>p</code> 从 <code>unique_ptr u</code> 那里接管对象的所有权，将 <code>u</code> 置为空</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(q, d)</td>
<td><code>p</code> 接管内置指针 <code>q</code> 所指向的对象的所有权，<code>p</code> 使用可调用对象 <code>d</code> 代替 <code>delete</code></td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(p2, d)</td>
<td><code>p</code> 是 <code>shared_ptr p2</code> 的拷贝，唯一区别为 <code>p</code> 调用 <code>d</code> 代替 <code>delete</code></td>
</tr>
<tr>
<td>p.reset()</td>
<td>释放对象</td>
</tr>
<tr>
<td>p.reset(q)</td>
<td>令 <code>p</code> 指向 <code>q</code></td>
</tr>
<tr>
<td>p.reset(q, d)</td>
<td><code>p</code> 调用 <code>d</code> 代替 <code>delete</code></td>
</tr>
</tbody>
</table>
<h4 id="131-">1.3.1 不能混合使用普通指针和智能指针</h4>
<ol>
<li>普通指针转换为智能指针</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">)</span><span class="p">{</span>
  	<span class="c1">//...
</span><span class="c1"></span><span class="p">}</span><span class="c1">// ptr 离开作用域被销毁
</span><span class="c1"></span>
<span class="kt">int</span> <span class="o">*</span><span class="nf">x</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">;</span>			<span class="c1">// 错误，不能将 int* 转换为 shared_ptr&lt;int&gt;
</span><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 当process 结束，会释放 x 所指向的内存
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>			<span class="c1">// 未定义：x 是空悬指针
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>智能指针转换为普通指针</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 正确：但使用时需注意，不要让它管理的指针被释放
</span><span class="c1"></span><span class="p">{</span>
  	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>		<span class="c1">// 程序块结束，则释放q 所指向的内存
</span><span class="c1"></span><span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>	<span class="c1">//未定义：p 所指向的内存已经被释放
</span></code></pre></td></tr></table>
</div>
</div><h4 id="132--shared-ptr-">1.3.2 其他 <code>shared_ptr</code> 操作</h4>
<ol>
<li>将新的指针赋予 一个 <code>shared_ptr</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 错误：不能讲一个指针赋予 shared_ptr
</span><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 正确：p 指向一个新对象
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>与 <code>uniqye</code> 一起使用，控制共享对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
  	<span class="n">p</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>		<span class="c1">//	如果我们不是唯一的用户，则重新分配新的拷贝
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">+</span><span class="o">=</span> <span class="n">newVal</span><span class="p">;</span>				<span class="c1">// 唯一用户，可进行修改
</span></code></pre></td></tr></table>
</div>
</div><h3 id="14-">1.4 智能指针和异常</h3>
<ul>
<li>智能指针在程序正常结束/ 发生异常都会被释放内存</li>
<li><code>new</code> 开辟的内存，在 <code>new</code> 与 <code>delete</code> 发生异常时，内存将无法释放</li>
</ul>
<h4 id="141-">1.4.1 智能指针与哑类</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">struct</span> <span class="nc">destination</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">connection</span><span class="p">;</span>
<span class="n">connection</span> <span class="nf">connect</span><span class="p">(</span><span class="n">destination</span><span class="o">*</span> <span class="p">)</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">connnection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// 使用连接
</span><span class="c1"></span>  	<span class="c1">// 在退出前没有 disconnect ,就无法关闭连接了
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种情况下，与 <code>new</code> 分配的动态内存类似，在发生异常 / 程序没有调用 <code>disconnect</code> 时，程序无法关闭连接。那么可以使用 <code>shared_ptr</code> 并给定 <code>deleter</code> 来管理关闭操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destionation</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">connection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">connect</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="n">end_connection</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// 使用连接
</span><span class="c1"></span>  	<span class="c1">// 在 f退出/ 发生异常时，connection 会被正确关闭
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>智能指针陷阱</p>
<ol>
<li>不使用相同的内置指针初始化(或 <code>reset</code> ) 多个智能指针</li>
<li>不 <code>delete</code> <code>get()</code>  返回的指针</li>
<li>不使用 <code>get()</code> 初始化或 <code>reset</code> 令一个智能指针</li>
<li>如果使用了 <code>get()</code> 返回的指针，当最后一个智能指针销毁后，指针就无效了</li>
<li>如果使用智能指针管理的资源不是 <code>new</code> 分配的资源，记得传递给它一个 <code>deleter</code></li>
</ol>
</blockquote>
<h3 id="15-unique-ptr">1.5 <code>unique_ptr</code></h3>
<ul>
<li>定义时，需要绑定到 <code>new</code> 返回的指针上，必须直接初始化</li>
<li>不支持普通的拷贝和赋值操作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">hello</span><span class="s">&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ps2</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 错误：unique_ptr 不支持拷贝
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ps3</span><span class="p">;</span>
<span class="n">ps3</span> <span class="o">=</span> <span class="n">ps</span><span class="p">;</span>											<span class="c1">// 错误：unique_ptr 不支持赋值
</span></code></pre></td></tr></table>
</div>
</div><p>可以通过 <code>release</code> / <code>reset</code> 将指针所有权从一个 (非 <code>const</code> )  <code>unique_ptr</code> 转移至另一个</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">hello</span><span class="s">&#34;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="n">p2</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>			<span class="c1">// 错误：p2 不会释放内存，而且丢失指针
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 正确：但必须记得 delete(p);
</span></code></pre></td></tr></table>
</div>
</div><p><code>unique_ptr</code> 操作</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique_ptr&lt;T&gt; u1<!-- raw HTML omitted -->unique_ptr&lt;T, D&gt; u2</td>
<td>定义 空的 <code>unique_ptr</code> ，默认使用 <code>delete</code>，<code>u2</code> 使用类型为 <code>D</code>  的可调用对象释放对象</td>
</tr>
<tr>
<td>unique_ptr&lt;T, D&gt; u(d)</td>
<td>空 <code>unique_ptr</code> ，指向类型为 <code>T</code> 的对象，用类型为 <code>D</code> 的对象 <code>d</code> 代替 <code>delete</code></td>
</tr>
<tr>
<td>u = nullptr</td>
<td>释放 <code>u</code> 指向的对象，将 <code>u</code> 置为空</td>
</tr>
<tr>
<td>u.release()</td>
<td><code>u</code> 放弃对指针的控制权，返回指针，并将 <code>u</code> 置为空</td>
</tr>
<tr>
<td>u.reset()</td>
<td>释放 <code>u</code> 指向的对象</td>
</tr>
<tr>
<td>u.reset(q)<!-- raw HTML omitted -->u.reset(nullptr)</td>
<td>如果提供内置对象，则令 <code>u</code> 指向该对象，否则将 <code>u</code> 置为空</td>
</tr>
</tbody>
</table>
<h4 id="151--unique-ptr---unique-ptr">1.5.1 传递 <code>unique_ptr</code> 和 返回 <code>unique_ptr</code></h4>
<p>不能拷贝 <code>unique_ptr</code> 的一个例外：将要销毁的 <code>unique_ptr</code> 可以拷贝和赋值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span><span class="p">{</span>
  	<span class="c1">// 正确，从 int* 创建一个 unique_ptr
</span><span class="c1"></span>  	<span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 返回局部对象的拷贝
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// ... 
</span><span class="c1"></span>  	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="152--unique-ptr--">1.5.2 向 <code>unique_ptr</code> 传递 删除器</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">objT</span><span class="p">,</span> <span class="n">delT</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="n">objT</span><span class="p">,</span> <span class="n">fcn</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="p">{</span>
  	<span class="n">connection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="p">;</span>
  	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">end_connection</span><span class="p">)</span><span class="o">*</span><span class="o">&gt;</span> 
      	<span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="n">end_connection</span><span class="p">)</span><span class="p">;</span>
  	<span class="c1">// 使用连接
</span><span class="c1"></span>  	<span class="c1">// 在 f退出 / 发生异常时，connection 会被正确关闭
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="16-weak-ptr">1.6 <code>weak_ptr</code></h3>
<p>   <code>weak_ptr</code> 指向一个 <code>shared_ptr</code> 管理的对象，但不会改变 其引用计数，一旦 <code>shared_ptr</code> 被销毁，对象就会被释放。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>weak_ptr&lt;T&gt; w</td>
<td>空 <code>weak_ptr</code></td>
</tr>
<tr>
<td>weak_ptr&lt;T&gt; w(sp)</td>
<td>与 <code>shared_ptr</code> 指向相同的对象</td>
</tr>
<tr>
<td>w = p</td>
<td><code>p</code> 可以是<code>shared_ptr</code> / <code>weak_ptr</code> ，赋之后 <code>w</code> 和 <code>p</code> 共享对象</td>
</tr>
<tr>
<td>w.reset()</td>
<td>将 <code>w</code> 置为空</td>
</tr>
<tr>
<td>w.use_count()</td>
<td>与 <code>w</code> 共享的 <code>shared_ptr</code> 的数量</td>
</tr>
<tr>
<td>w.expired()</td>
<td>若 <code>w.use_count=0</code> 返回 <code>true</code> ，否则返回 <code>false</code></td>
</tr>
<tr>
<td>w.lock()</td>
<td>若 <code>expired()</code> 为 <code>true</code> ，返回一个空的 <code>shared_ptr</code>， 否则返回指向<code>w</code> 的<code>shared_ptr</code></td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="p">;</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="p">;</span>		<span class="c1">// 弱共享 p，p 的引用计数未改变
</span><span class="c1"></span>
<span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">{</span>	<span class="c1">// np 不为空，条件成立
</span><span class="c1"></span>  	<span class="c1">// if 中，np 与 wp 共享对象
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-">2 动态数组</h2>
<p>容器在重新分配内存时，必须一次性为很多元素分配内存：</p>
<ol>
<li><code>new</code> 表达式</li>
<li>标准库中的 <code>allocator</code> 类</li>
</ol>
<h3 id="21-new-">2.1 <code>new</code> 和数组</h3>
<ol>
<li>调用 <code>get_size</code> , 方括号中必须是整数，但不必是常量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="o">*</span><span class="n">pia</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">get_size</span><span class="p">(</span><span class="p">)</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>使用类型别名</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">42</span><span class="p">]</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">42</span><span class="p">]</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">arrT</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>分配数组内存会得到一个元素类型的指针，动态数组并不是数组类型。</p>
</blockquote>
<h4 id="211-">2.1.1 初始化动态分配对象的数组</h4>
<ol>
<li>值初始化</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="o">*</span><span class="n">pia</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">;</span>			<span class="c1">// 10 个未初始化的 int
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pia2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 10 个初始化为 0 的int
</span><span class="c1"></span>
<span class="kt">int</span> <span class="o">*</span><span class="n">psa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">;</span>		<span class="c1">// 10个空string
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">psa2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 10个空string
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>列表初始化</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="o">*</span><span class="n">pia3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span><span class="p">;</span>
<span class="n">string</span> <span class="o">*</span><span class="n">psa3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">{</span><span class="sa"></span><span class="s">&#34;</span><span class="s">a</span><span class="s">&#34;</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">an</span><span class="s">&#34;</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">the</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">x</span><span class="s">&#34;</span><span class="p">)</span><span class="p">}</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="212-">2.1.2 分配一个空数组是合法的</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">size_t</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!</span><span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">;</span> <span class="o">+</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
  	<span class="c1">// ... 
</span><span class="c1"></span>  
<span class="kt">char</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>		<span class="c1">// 错误：不能定义长度为 0 的数组
</span><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>	<span class="c1">// 正确：但cp 不能解引用
</span></code></pre></td></tr></table>
</div>
</div><h4 id="213-">2.1.3 释放动态数组</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">pa</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="214-">2.1.4 智能指针与动态数组</h4>
<ol>
<li><code>unique_ptr</code> 管理动态数组</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
<span class="n">up</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>			<span class="c1">// 自动调用 delete[] 销毁其指针
</span><span class="c1"></span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
  	<span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><code>shared_ptr</code> 不直接支持，但可以通过提供自己的 <code>deleter</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span><span class="p">{</span><span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">p</span><span class="p">;</span><span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
  	<span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="22-allocator-">2.2 <code>allocator</code> 类</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// 分配 n 个未初始化的 string
</span></code></pre></td></tr></table>
</div>
</div><p>标准库 <code>allocator</code> 类及其算法</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>allocator&lt;T&gt; a</td>
<td>定义一个 名为 <code>a</code> 的 <code>allocator</code> 对象，可以为 类型 <code>T</code> 分配内存</td>
</tr>
<tr>
<td>a.allocator(n)</td>
<td>分配一段原始的，未构造的内存，保存 <code>n</code> 个 <code>T</code> 对象</td>
</tr>
<tr>
<td>a.deallocator(p, n)</td>
<td>释放从 <code>T*</code> 指针 <code>p</code> 开始的内存，内存中的 <code>n</code> 个 <code>T</code> 对象，在调用前，必须将 创建的每个对象调用 <code>destroy</code></td>
</tr>
<tr>
<td>a.construct(p, <em>args</em>)</td>
<td><code>p</code> 是一段原始的内存，<em>args</em> 传递为 <code>T</code> 的构造函数参数</td>
</tr>
<tr>
<td>a.destory(p)</td>
<td>对 <code>p</code> 指向的函数的析构函数</td>
</tr>
</tbody>
</table>
<h4 id="221-allocator-">2.2.1 <code>allocator</code> 分配未构造的内存</h4>
<ol>
<li>构造对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="o">+</span><span class="p">)</span><span class="p">;</span>						<span class="c1">// *q 为空字符串
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="o">+</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">c</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>	<span class="c1">// *q 为 &#39;cccccccccc&#39;
</span><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="o">+</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">hi</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>			<span class="c1">// *q 为 hi
</span><span class="c1"></span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">// 正确：使用 string 的输出运算符
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">// 灾难：q 指向未构造的内存
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>销毁对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">while</span><span class="p">(</span><span class="n">q</span> <span class="o">!</span><span class="o">=</span> <span class="n">p</span><span class="p">)</span>
  	<span class="n">alloc</span><span class="p">.</span><span class="n">destory</span><span class="p">(</span><span class="o">-</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>释放内存</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="222-">2.2.2 拷贝和填充未初始化的算法</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>uninitialized_copy(b, e, b2)</td>
<td>将迭代器范围 <code>b</code> <code>e</code> 中的元素拷贝至 <code>b2</code></td>
</tr>
<tr>
<td>uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器<code>b</code> 指向的元素开始，拷贝 <code>n</code> 个元素至 <code>b2</code> 开始的内存</td>
</tr>
<tr>
<td>uninitialized_fill(b, e, t)</td>
<td>将迭代器范围 <code>b</code> <code>e</code> 创建对象，对象的值为 <code>t</code> 的拷贝</td>
</tr>
<tr>
<td>uninitialized_fill_n(b, n, t)</td>
<td>从迭代器<code>b</code> 指向的元素开始，拷贝 <code>n</code> 个值为 <code>t</code> 的元素</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="p">;</span>
<span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">olOwOlo</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%E5%8D%81%E4%B8%89%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"></span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%E5%8D%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">olOwOlo</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
